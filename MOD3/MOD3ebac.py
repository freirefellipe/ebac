# -*- coding: utf-8 -*-
"""MOD3ebac.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1j065LjHmtCX8ljUAv1Mypqe-uIWrB-_1

# Uso do if-else:
"""

pin_cadastrado = '0000'
pin_inserido = str(input('Insira o PIN: '))

senha_cadastrada = 'abcde'
senha_inserida = input('Insira a senha: ')

if (pin_cadastrado == pin_inserido) and (senha_cadastrada == senha_inserida):
  print('Pagamento efetuado com sucesso.')

elif (pin_cadastrado != pin_inserido) and (senha_cadastrada == senha_inserida):
  print('PIN incorreto.')

elif (pin_cadastrado == pin_inserido) and (senha_cadastrada != senha_inserida):
  print('Senha incorreta.')

"""# outra forma de se usar o if-else em uma só linha:"""

print('PIN ou senha incorreta.') if (pin_cadastrado != pin_inserido) or (senha_cadastrada != senha_inserida) else print('Pagamento efetuado com sucesso.')

"""

# Uso do Try-except-finally:"""

lista = ['zero', 'um', 'dois', 'três']

try:
  elem_escolhendo = int(input('Qual índice do elemento desejado? > '))
  elem_escolhido = lista[elem_escolhendo]
  print(elem_escolhido)
except ValueError:
  print('Só pode digitar número.')
except IndexError:
  print('Só pode digitar de 0 a 3.')
except Exception as error: # a exceção genérica deve vir por último para não impedir o tratamento da exceção específica
  display(str(error))
  display(type(error))
  display(error)
finally: # acontece com ou sem exceção.
  print('Final do código.')

"""Se a exceção for tratada, o códgio continuará, independente do finally.

# Utilizando-se o **pass** ou **continue**, **logging** e **raise** dentro do código:
"""

import logging # vai ser usado com Exception, para registrar o tipo do erro ocorrido.

try:
  inputvalue = int(input('Insira um valor de 1 a 100 para dividir 100: '))
  if (inputvalue > 100):
    raise print('denomidador maior que o numerador. Somente divisão real') # raise cria uma exceção. É possível escrever somente raise e o programa para.
  print(100/inputvalue)
except ZeroDivisionError as zerodiv:
  print(str(zerodiv))
except (ValueError, TypeError):
  pass # ou 'continue'(possíveis, mas o recomendável é sempre explicar a exceção)
except Exception as othererror:
  logging.exception(othererror)
else:
  print('Fim do código. Nanhum erro apresentado.')

"""# Usando laço **for**-**in**:"""

frase = '''Miyamoto Musashi Died On This Day, June 13, 1645.

One of the most famous samurai of all time, Miyamoto Musashi’s reputation has grown to mythic proportions over the years,
despite much of his life remaining a mystery. The undefeated swordsman, master of strategy, calligrapher, painter, writer and martial arts icon,
Miyamoto Musashi was born towards the end of the warring States period. He took part in a great many battles and duels,
created his own unique sword style and wrote one of the best known and widest read books on strategy, confrontation and victory.'''

char_escolhido_1 = 'aa'
char_escolhido_2 = 'bb'

count_char_1 = 0
count_char_2 = 0

while (len(char_escolhido_1) >1) or (len(char_escolhido_2) > 1):
  print('Insira somente um caractere para cada.')
  char_escolhido_1 = str(input('Insira o caractere que você quer buscar na frase: '))
  char_escolhido_2 = str(input('Insira outro caractere que você quer buscar na frase: '))

for char in frase:
  if char == char_escolhido_1:
    count_char_1 += 1
    print(f'Caractere {char_escolhido_1} encontrado.')
  if char == char_escolhido_2:
    count_char_2 += 1
    print(f'Caractere {char_escolhido_2} encontrado.')


print(f'''{count_char_1} vez(es) o "{char_escolhido_1}", e {count_char_2} vez(es) o "{char_escolhido_2}" no texto: \n {frase}''')

"""# Laço **for**-**in** com dicionários:

Forma preferível...
"""

credito = {'123':748, '456':629,'789':367}

for chave, valor in credito.items(): # .items() cria uma lista sendo cada elemento da lista um parêntese contendo respectivamente a chave e o valor separados por vírgula: [(chave, valor),(chave, valor)]
  print(f'O valor da chave {chave} é {valor}')

"""Outra forma de fazer, sem o .items() é a seguinte:"""

credito = {'123':748, '456':629,'789':367}

for chave in credito.keys(): # em dicionários, é possível assim como o .keys(), o .values() para buscar os valores.
  print(f'O valor da chave {chave} é {credito[chave]}')

"""# Podemeos fazer laços com contagem, utilizando o **range**, **break** e **continue**:"""

for count in range(2, 2000, 2):
  print(count)

  if count >= 20:
    break
  else:
    continue
    print('Esse print não vai ser executado, uma vez que o continue faz o programa ir para a próxima iteração')
